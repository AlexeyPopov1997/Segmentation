# Мктодология программной инженерии: Вводная лекция

## Клименков Сергей Викторович
* **Кабинеты**: 373 (374)
* **Вконтакте**: vk.con/serge_klimenkov
* **Сайт**: https://se.ifmo.ru/

### Учебники:
* UNL 2 и унифицированный процесс (Д. Арлоу, А. Нейштардт)
* Программная инженерия (С. Орлов)
* Изучаем Java (К. Сьерра, Б. Бейтс)

## Rational Unified Process (RUP)
**Rational Unified Process (RUP)** — методология разработки программного обеспечения, созданная компанией Rational Software. 

### Принципы
В основе RUP лежат следующие принципы:
* Ранняя идентификация и непрерывное (до окончания проекта) устранение основных рисков.
* Концентрация на выполнении требований заказчиков к исполняемой программе (анализ и построение модели прецедентов (вариантов использования)).
* Ожидание изменений в требованиях, проектных решениях и реализации в процессе разработки.
* Компонентная архитектура, реализуемая и тестируемая на ранних стадиях проекта.
* Постоянное обеспечение качества на всех этапах разработки проекта (продукта).
* Работа над проектом в сплочённой команде, ключевая роль в которой принадлежит архитекторам.

### Процессы и стадии RUP
RUP использует итеративную модель разработки. В конце каждой итерации (в идеале продолжающейся от 2 до 6 недель) проектная команда должна достичь запланированных на данную итерацию целей, создать или доработать проектные артефакты и получить промежуточную, но функциональную версию конечного продукта. Итеративная разработка позволяет быстро реагировать на меняющиеся требования, обнаруживать и устранять риски на ранних стадиях проекта, а также эффективно контролировать качество создаваемого продукта. Первые идеи итеративной модели разработки были заложены в "спиральной модели".

Полный жизненный цикл разработки продукта состоит из четырёх фаз, каждая из которых включает в себя одну или несколько итераций:

![img](https://upload.wikimedia.org/wikipedia/ru/d/da/RUP_process.png)

**1. Начальная стадия (Inception)**
В фазе начальной стадии:
* Формируются видение и границы проекта.
* Создается экономическое обоснование (business case).
* Определяются основные требования, ограничения и ключевая функциональность продукта.
* Создается базовая версия модели прецедентов.
* Оцениваются риски.
* При завершении начальной фазы оценивается достижение этапа жизненного цикла цели (Lifecycle Objective Milestone), которое предполагает соглашение заинтересованных сторон о продолжении проекта.

**2. Уточнение (Elaboration)**
В фазе «Уточнение» производится анализ предметной области и построение исполняемой архитектуры. Это включает в себя:
* Документирование требований (включая детальное описание для большинства прецедентов).
* Спроектированную, реализованную и оттестированную исполняемую архитектуру.
* Обновленное экономическое обоснование и более точные оценки сроков и стоимости.
* Сниженные основные риски.
* Успешное выполнение фазы уточнения означает достижение этапа жизненного цикла архитектуры (Lifecycle Architecture Milestone).

**3. Построение (Construction)**
В фазе «Построение» происходит реализация большей части функциональности продукта. Фаза Построение завершается первым внешним релизом системы и вехой начальной функциональной готовности (Initial Operational Capability).

**4. Внедрение (Transition)**
В фазе «Внедрение» создается финальная версия продукта и передается от разработчика к заказчику. Это включает в себя программу бета-тестирования, обучение пользователей, а также определение качества продукта. В случае, если качество не соответствует ожиданиям пользователей или критериям, установленным в фазе Начало, фаза Внедрение повторяется снова. Выполнение всех целей означает достижение вехи готового продукта (Product Release) и завершение полного цикла разработки.

## Практика

**1) Программное обеспечение должно запускаться на кафедральных серверах.**

**2) Программное обеспечеие должно запускаться на JVM**

**3) Программное обеспечение должно соответствовать понятию *информационной системы***

**Информационная система** — система, предназначенная для хранения, поиска и обработки информации, и соответствующие организационные ресурсы (человеческие, технические, финансовые и т. д.), которые обеспечивают и распространяют информацию.

Информационная система предназначена для своевременного обеспечения надлежащих людей надлежащей информацией, то есть для удовлетворения конкретных информационных потребностей в рамках определённой предметной области, при этом результатом функционирования информационных систем является информационная продукция — документы, информационные массивы, базы данных и информационные услуги.

**4) Необходимо предоставить отрывок из художественного произведения с автоматизиркемым бизнес-процессом.**

# UML  (Unified Modeling Language)

Cуществует три способа использования **UML**:
* **UML как эскиз** – это неформальный подход к UML, при котором используется схематическое изображение диаграмм, помогающее визуализировать программную систему. Это несколько схоже с наброском идеи на обратной стороне салфетки. Эскизы не представляют практически никакой ценности кроме их исходного применения, не сохраняются и в конце концов выбрасываются. Для создания неформальных эскизов обычно используют доску или инструментальныесредства рисования, такие как *Visio* и *PowerPoint*.
* **UML как модель** – это более формальный и точный подход, при котором UML используется для подробного описания программной системы. Это как набор архитекторских планов или чертеж машины. UML модель активно поддерживается и становится важным поставляемым артефактом проекта. Этот подход требует использования настоящего инструментального средства моделирования, такого как *Rational Rose* или *MagicDraw UML*.
* **UML как исполняемый проект** – с помощью *MDA* (*Model Driven Architecture* – архитектура, управляемая моделью) UML модели могут использоваться как язык программирования. Создается достаточно подробная UML модель, и система может быть скомпилирована прямо из нее. Это самое формальное и точное применение UML и, по нашему мнению, это будущее разработки программного обеспечения. При таком подходе необходим UML инструмент, поддер живающий MDA, такой как *ArcStyler*.

## Введение в UML и UP

**Унифицированный язык моделирования (Unified Modeling Language, UML)** – это универсальный язык визуального моделирования систем. Хотя чаще всего UML ассоциируется с моделированием ОО программных систем, он имеет намного более широкое применение благодаря свойственной ему расширяемости.

**UML это не методология, это унифицированный язык визуального моделирования. UP – это методология.**

**Унифицированный процесс (Unified Process, UP)** – это методология. Она указывает на исполнителей, действия и артефакты, которые необходимо использовать, осуществить или создать для моделирования программной системы.

UML – открытый, принятый в качестве промышленного стандарта язык визуального моделирования, одобренный OMG.

### MDA – будущее UML

Будущее UML может быть определено, согласно недавнему предложению OMG, как архитектура, управляемая моделью (**Model Driven Architecture, MDA**).

**MDA** дает видение того, как разрабатывать програмное обеспечение на основе моделей. Суть этого видения заключается в том, что модели управляют созданием исполняемой программной архитектуры.

В MDA создание программного обеспечения происходит в результате ряда трансформаций модели при поддержке инструмента моделирования MDA. **Абстрактная машиннонезависимая модель (computer-independent model, CIM)** используется как основа для **платформонезависимой модели (platform-independent model, PIM)**. **PIM** трансформируется в **платформозависимую модель (platform-specific model, PSM)**, которая преобразуется в код.

![imd](https://www.modeliosoft.com/images/mda_technology.png)

Понятие модели в MDA является довольно обобщенным, и **код** рассматривается как сильно конкретизированный вид модели.

**CIM** – это модель с очень высоким уровнем абстракции, фиксирующая ключевые требования системы и словарь предметной области независимым от компьютеров способом. Это действительно модель той части бизнес-процесса, которую предполагается автоматизировать. Такую модель создавать необязательно, и если она разрабатывается, то используется как основа для выработки **PIM**.

**PIM** – модель, выражающая семантику деятельности программной системы без ориентации на какую-либо базовую платформу (такую как EJB, .NET и т. д.). **PIM** обычно находится примерно на том же уровне абстракции, что и аналитическая модель, о которой пойдет речь несколько позже, но является более полной. Это является необходимым
условием, поскольку данная модель должна обеспечивать достаточно полную базу для трансформации в **PSM**, из которой может быть сгенерирован код. В определении «платформонезависимый» немного смысла, пока точно не указаны платформы, от которых необходимо обеспечить независимость! Разные инструменты MDA поддерживают разные уровни независимости от платформы.

**PIM** дополняется характерной для конкретной платформы информацией для создания **PSM**. Из **PSM** генерируется исходный код под определенную платформу. В принципе 100% исходного кода и вспомогательных артефактов, таких как документация, средства тестирования, файлы сборки и дескрипторы развертывания, могут генерироваться из достаточно полной **PSM**. Если это предполагается, модель UML должна быть полной в вычислительном отношении, иначе говоря, семантика всех операций должна быть определена на языке действий.

В представлении MDA исходный код, такой как код на Java или C#, – это просто «машинный код», получающийся в результате компиляции моделей UML. Этот код генерируется в случае необходимости прямо из PSM. По существу, ценность кода при разработке с применением MDA значительно ниже, чем в UML-моделях. MDA превращает модели UML из прообраза создаваемого вручную исходного кода в основной механизм производства кода.

### Унификация UML

UML прилагает усилия в унификации нескольких разных областей:
* **Жизненный цикл разработки**: UML предоставляет визуальный синтаксис для моделирования на протяжении всего жизненного цикла разработки программного обеспечения – от постановки требований до реализации.

* **Области приложений**: UML используется для моделирования всех аспектов – от аппаратных встроенных систем реального времени до систем поддержки принятия решений.

* **Языки реализации и платформы**: UML является независимым от языков и платформ. Естественно, он прекрасно поддерживает чистые ОО языки (Smalltalk, Java, C# и др.), но также эффективен и для гибридных ОО языков, таких как C++, и основанных на концепции объектов, таких как Visual Basic. UML также используется для создания моделей, реализуемых на неОО языках программирования, таких как С.

* **Процессы разработки**: хотя UP и его разновидности, вероятно, являются предпочтительными процессами разработки ОО систем, UML может поддерживать (и поддерживает) множество других процессов разработки ПО.

* **Собственные внутренние концепции**: UML поистине стойко стремится сохранить последовательность и постоянство применения небольшого набора своих внутренних концепций. До сих пор это не всегда удавалось, но в этом направлении наблюдается заметный прогресс по сравнению с предыдущими попытками.

### Объекты и UML

Основная идея UML – возможность моделировать программное обеспечение и другие системы как наборы взаимодействующих объектов. Это, конечно же, замечательно подходит для ОО программных систем и языков программирования, но также очень хорошо работает и для бизнес-процессов и других прикладных задач.

В UML-модели есть два аспекта:

* **Статическая структура** – описывает, какие типы объектов важны для моделирования системы и как они взаимосвязаны.
* **Динамическое поведение** – описывает жизненные циклы этих объектов и то, как они взаимодействуют друг с другом для обеспечения требуемой функциональности системы. 

Эти два аспекта модели UML идут рука об руку, и ни один из них не является по настоящему полным без другого.

**UML моделирует мир как системы взаимодействующих объектов. Объект – это цельный блок, состоящий из данных и функциональности.**

### Структура UML

Эта структура включает:
* **Cтроительные блоки** – основные элементы, отношения и диаграммы UML-модели;

* **Общие механизмы** – общие UML-пути достижения определенных целей;

* **Архитектура** – UML-представление архитектуры системы.

#### Строительные блоки UML

UML состоит всего из трех строительных блоков:
* **Сущности** – это сами элементы модели.

* **Отношения** связывают сущности. Отношения определяют, как семантически связаны две или более сущностей.

* **Диаграммы** – это представления моделей UML. Они показывают наборы сущностей, которые «рассказывают» о программной системе и являются нашим способом визуализации того, что будет делать система (**аналитические диаграммы**) или как она будет делать это (**проектные диаграммы**).

**«Сущности» – это существительные UML-модели.**

Все UML-сущности можно разделить на:

* *Cтруктурные сущности* – существительные UML-модели, такие как класс, интерфейс, кооперация, прецедент, активный класс, компонент, узел;

* *Поведенческие сущности* – глаголы UML-модели, такие как взаимодействия, деятельности, автоматы;

* *Группирующая сущность* – пакет, используемый для группировки семантически связанных элементов модели в образующие единое целое модули;

* *Аннотационная сущность* – примечание, которое может быть добавлено к модели для записи специальной информации, очень похожее на стикер.

**Отношения в модели UML позволяют зафиксировать значимые (семантические) связи между сущностями.**

**Диаграммы – это только представления модели.**

Типы UML-диаграмм:

![img](https://www.intuit.ru/EDI/22_04_18_1/1524349366-16457/tutorial/324/objects/3/files/03-01.jpg)

Эти диаграммы можно разделить на те, которые моделируют **статическую структуру системы (статическую модель)**, и те, которые моделируют **динамическую структуру системы (динамическую модель)**. Статическая модель фиксирует сущности и структурные отношения между ними; динамическая модель отображает, как сущности взаимодействуют для генерирования требуемого поведения программной системы.

### Общие механизмы UML

В UML существует четыре общих механизма, последовательно применяемых ко всему языку моделирования. Они описывают четыре стратегии подхода к моделированию объектов, которые в разных контекстах многократно применяются в UML. 

![img](https://4.bp.blogspot.com/-YBwKfFhO2Zk/TbqLARdRGuI/AAAAAAAAAJM/1No53n42Png/s1600/Mechanisms.png)

### Спецификации

**Спецификации – это суть UML-модели. Они обеспечивают семантический задний план модели.**

Модели UML имеют, по крайней мере, два измерения: графическое, позволяющее визуализировать модель с помощью диаграмм и пиктограмм, и текстовое, состоящее из спецификаций различных элементов модели. Спецификации – это текстовые описания семантики элемента.

**Набор спецификаций – это суть модели**. Спецификации формируют **семантический задний план (semantic backplane)**, который объединяет модель и наполняет ее смыслом. Различные диаграммы – это просто представления или визуальные проекции этого плана.

### Дополнения 

**Мы дополняем элементы модели на UML-диаграммах, чтобы подчеркнуть важные детали.**

### Принятые деления

####  Классификатор и экземпляр

Абстрактное понятие типа сущности – это **классификатор**, а отдельные конкретные сущности – **экземпляры**.

**Классификатор** – это абстрактное понятие, например тип банковского счета. **Экземпляр** – конкретная сущность, например ваш банковский счет или мой банковский счет.

#### Интерфейс и реализация

**Интерфейс** – это, например, кнопки на панели видеомагнитофона. **Реализация** – устройство видеомагнитофона.

### Механизмы расширения

#### Ограничения

**Ограничения позволяют добавлять новые правила в элементы модели.**

**Ограничение** – это строка текста, заключенная в фигурные скобки ({ }), определяющая некоторое условие или правило для элемента модели, которое должно оставаться истинным.

#### Стереотипы

**Стереотипы позволяют определять новые элементы модели.**

#### Помеченные значения

**Помеченные значения позволяют добавлять собственные свойства к элементам модели.**

В UML свойство – это любое значение, прикрепленное к элементу модели. Большинство элементов имеют большое число предопределенных свойств. Некоторые из них могут отображаться на диаграммах, другие являются частью семантического заднего плана модели.

С помощью помеченных значений UML позволяет добавлять в элементы модели собственные свойства. 

#### Профили UML

**Профиль UML определяет набор стереотипов, меток и ограничений, которые настраивают UML в соответствии с определенной целью.**

## Архитектура

Архитектура описывает фундаментальные аспекты высокоуровневой структуры системы. Существует множество способов описания архитектуры, но самым распространенным является «4+1 представление»:

**Стратегические аспекты системы можно описать «4+1 представлениями» архитектуры: логическое представление, представление процессов,представление реализации, представление развертывания и представление прецедентов.**

* **Логическое представление** описывает словарь предметной области как набор классов и объектов. Основное внимание уделяется отображению того, как объекты и классы, образующие систему, реализуют требуемое поведение системы.

* **Представление процессов** моделирует исполняемые потоки и процессы системы как активные классы (классы, имеющие собственный поток управления). В действительности это процессориентированная версия логического представления, все их артефакты аналогичны.

* **Представление реализации** моделирует файлы и компоненты, образующие физическую базу из кода для системы. Это представление также иллюстрирует зависимости между компонентами и управляет конфигурированием наборов компонентов для определения версии системы.

* **Представление развертывания** моделирует физическое развертывание артефактов на физические вычислительные узлы, такие как компьютеры и периферийное оборудование. Оно обеспечивает возможность моделирования распределения артефактов между узлами распределенной системы.

* **Представление прецедентов** описывает основные требования, предъявляемые к системе, как набор прецедентов. Эти прецеденты обеспечивают базу для создания остальных представлений.

**UP является управляемым требованиями подходом, для которого замечательно подходит модель 4+1.**



# UP (Unified Process)

**Процесс производства программного обеспечения (Software Engineering Process, SEP)**, также известный как **процесс разработки программного обеспечения (Software Development Process)**, определяет *кто*,*что*, *когда* и *как* в разработке ПО . **SEP** – это процесс, в котором требования пользователя превращаются в ПО.

**Унифицированный процесс разработки программного обеспечения (Unified Software Development Process, USDP)** – это **SEP** от авторов UML. Обычно его называют Унифицированным процессом или **UP**.

**Процесс производства программного обеспечения описывает то, как требования превращаются в программное обеспечение.**

***UP* – это сложившийся открытый SEP от авторов UML.**

## RUP и UP

**RUP** – это коммерческий продукт, расширяющий **UP**.

**Унифицированный процесс компании Rational (Rational Unified Process, RUP)** – это коммерческая версия UP от IBM, которая поглотила Rational Corporation в 2003 году. Он предоставляет стандарты, инструментальные средства и остальные необходимые элементы, которые не включены в UP и которые пользователям в противном случае пришлось
бы искать самостоятельно. Он также поставляется с богатым веб-окружением, включающим всю документацию процесса и полные руководства для каждого инструментального средства.

**У процессов UP и RUP больше общего, чем отличий.**

И **UP**, и **RUP** моделируют кто, когда и что в процессе разработки программного обеспечения, но делают это немного по разному. Самая последняя версия **RUP** имеет некоторые отличия от **UP** в терминологии и синтаксисе, хотя семантика элементов процесса остается, по сути, прежней.

Соответствие пиктограмм UP и RUP:

![img](https://studme.org/htm/img/15/2316/166.png)

**UP** (и **RUP**) должны настраиваться под каждый конкретный проект путем добавления внутренних стандартов и др.

**UP** – это современный *SEP*, который является:
* управляемым рисками и прецедентами (требованиями);
* архитектуро-центричным;
* итеративным и инкрементным.

В UP программное обеспечение создается через итерации:
* каждая итерация подобна мини-проекту, создающему часть системы;

* для создания окончательной системы итерации надстраиваются друг над другом.

В каждой итерации пять основных рабочих потоков:

* **определение требований** – выяснение того, что должна делать система;

* **анализ** – конкретизация и структурирование требований;

* **проектирование** – реализация требований в архитектуре системы (как система это делает);

* **реализация** – построение программного обеспечения;

* **тестирование** – проверяется, работает ли должным образом реализация.

В UP четыре фазы, каждая из которых заканчивается важной контрольной точкой:
* **Начало** – проект сдвигается с «мертвой точки»: Цели жизненного цикла;

* **Уточнение** – развитие архитектуры системы: Архитектура жизненного цикла;

* **Построение** – построение программного обеспечения: Базовая функциональность;

* **Внедрение** – развертывание программного обеспечения в пользовательской среде: Выпуск продукта.
